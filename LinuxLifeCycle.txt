
                    Linux Lifecycle & Processes

A process in a computer operating system is an executable program in action. The executable program has machine instructions necessary to carry out a specific task. A corresponding process is born when a program is executed for carrying out a task. A programmer writes a software program using a high-level programming language such as C. This is also called ‘code’ and the programmer compiles it to create an executable program. The compilation process converts the code into a set of machine-level instructions, and it becomes intelligible to the operating system. The compiler for Linux systems is GCC or Gnu C Compiler.

The executable program remains a passive entity, until it is instructed to run or execute by the user. Then it creates a new entity called a process, which is visible by the command ‘ps’. The process is associated with three identifiers – the Process ID or PID, the Parent Process ID or PPID and the Group ID or GID.

In a Linux system, the first process to start is the ‘init’ and it has a PID of 1. All subsequent processes are init’s children, grandchildren and so on. For active process in a Linux system, the command ‘pstree’ will bring up the entire hierarchy, while ‘top’ will show the dynamic view of processes. The Linux kernel uses a scheduler and it controls the execution sequence of all the processes. Linux processes can have one of four states at any given time: running, waiting or sleeping, stopped and zombie.

A process achieves a running state when it is actually executing (running) or waiting for execution in the queue of the scheduler, which means it is ready to run or execute. For this reason, the running state is also known as runnable and is represented by R.

A process is in a waiting or sleeping state if it must wait for an event to occur or some resource-specific operation needs to complete before the process can continue to run. Therefore, depending on the circumstances, the waiting state is further subcategorized into an interruptible or S state and an uninterruptible or D state.

If the scheduler sends a stop signal to a process, the process goes into a stopped state. This might happen, for example, when the process is being debugged or analyzed and this state is represented by T.

When a process has completed its execution, but is waiting to retrieve its exit state, the process is said to be in a zombie state, designated by Z. Once it crosses the zombie state or retrieves its exit status, the process dies or ceases to exist.